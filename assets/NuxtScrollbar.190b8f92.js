import{a as m,s as $,t as j,af as A,ab as D,b as R,u as T,g as P,ag as H,r as z,j as E,R as M,L as K,Y as N,A as b,B as C,C as y,H as S,E as q,F as I,U as w,D as W,z as F,ah as L}from"./swiper-vue.5b215f1a.js";import{y as U,s as _,z as k,u as G,A as V,_ as Y}from"./entry.fccda37e.js";function J(...s){var g;const r=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(r);let[e,o,a={}]=s;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=_(),u=()=>null,f=()=>t.isHydrating?t.payload.data[e]:t.static.data[e];a.server=a.server??!0,a.default=a.default??u,a.getCachedData=a.getCachedData??f,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??U.deep;const l=()=>![null,void 0].includes(a.getCachedData(e));if(!t._asyncData[e]||!a.immediate){(g=t.payload._errors)[e]??(g[e]=null);const i=a.deep?m:$;t._asyncData[e]={data:i(a.getCachedData(e)??a.default()),pending:m(!l()),error:j(t.payload._errors,e),status:m("idle")}}const n={...t._asyncData[e]};n.refresh=n.execute=(i={})=>{if(t._asyncDataPromises[e]){if(i.dedupe===!1)return t._asyncDataPromises[e];t._asyncDataPromises[e].cancelled=!0}if((i._initial||t.isHydrating&&i._initial!==!1)&&l())return Promise.resolve(a.getCachedData(e));n.pending.value=!0,n.status.value="pending";const h=new Promise((c,d)=>{try{c(o(t))}catch(B){d(B)}}).then(c=>{if(h.cancelled)return t._asyncDataPromises[e];let d=c;a.transform&&(d=a.transform(c)),a.pick&&(d=Q(d,a.pick)),t.payload.data[e]=d,n.data.value=d,n.error.value=null,n.status.value="success"}).catch(c=>{if(h.cancelled)return t._asyncDataPromises[e];n.error.value=k(c),n.data.value=T(a.default()),n.status.value="error"}).finally(()=>{h.cancelled||(n.pending.value=!1,delete t._asyncDataPromises[e])});return t._asyncDataPromises[e]=h,t._asyncDataPromises[e]};const p=()=>n.refresh({_initial:!0}),O=a.server!==!1&&t.payload.serverRendered;{const i=P();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const c=i._nuxtOnBeforeMountCbs;i&&(A(()=>{c.forEach(d=>{d()}),c.splice(0,c.length)}),D(()=>c.splice(0,c.length)))}O&&t.isHydrating&&(n.error.value||l())?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):i&&(t.payload.serverRendered&&t.isHydrating||a.lazy)&&a.immediate?i._nuxtOnBeforeMountCbs.push(p):a.immediate&&p(),a.watch&&R(a.watch,()=>n.refresh());const h=t.hook("app:data:refresh",async c=>{(!c||c.includes(e))&&await n.refresh()});i&&D(h)}const v=Promise.resolve(t._asyncDataPromises[e]).then(()=>n);return Object.assign(v,n),v}function Q(s,r){const e={};for(const o of r)e[o]=s[o];return e}const x="__nuxt_component";async function X(s,r){const e=_(),o=V(),a=P(),{fetchKey:t,_fetchKeyBase:u}=a.proxy.$options,f=(typeof t=="function"?t(()=>""):t)||[u,o.fullPath,o.matched.findIndex(p=>Object.values(p.components||{}).includes(a.type))].join(":"),{data:l,error:n}=await J(`options:asyncdata:${f}`,()=>e.runWithContext(()=>r(e)));if(n.value)throw k(n.value);l.value&&typeof l.value=="object"&&Object.assign(await s,H(z(l.value)))}const Z=function(...r){const[e,o]=r,{setup:a}=e;return!a&&!e.asyncData&&!e.head?{[x]:!0,...e}:{[x]:!0,_fetchKeyBase:o,...e,setup(t,u){const f=_(),l=a?Promise.resolve(f.runWithContext(()=>a(t,u))).then(p=>p||{}):{},n=[];if(e.asyncData&&n.push(X(l,e.asyncData)),e.head){const p=_();G(typeof e.head=="function"?()=>e.head(p):e.head)}return Promise.resolve(l).then(()=>Promise.all(n)).then(()=>l).finally(()=>{n.length=0})}}},ee=E({name:"ClientOnly",inheritAttrs:!1,props:["fallback","placeholder","placeholderTag","fallbackTag"],setup(s,{slots:r,attrs:e}){const o=m(!1);return M(()=>{o.value=!0}),a=>{var l;if(o.value)return(l=r.default)==null?void 0:l.call(r);const t=r.fallback||r.placeholder;if(t)return t();const u=a.fallback||a.placeholder||"",f=a.fallbackTag||a.placeholderTag||"span";return K(f,e,u)}}}),ae=Z({props:{options:{type:Object,required:!1,default:()=>({})},tag:{type:String,required:!1,default:"div"},watchOptions:{type:Boolean,required:!1,default:!1}},computed:{handlers(){return["scroll","ps-scroll-y","ps-scroll-x","ps-scroll-up","ps-scroll-down","ps-scroll-left","ps-scroll-right","ps-y-reach-start","ps-y-reach-end","ps-x-reach-start","ps-x-reach-end"].reduce((r,e)=>(r[e]=(...o)=>this.$emit(e,...o),r),{})}}},"$5GjKioyWkT");function te(s,r,e,o,a,t){const u=N("perfect-scrollbar"),f=ee;return b(),C(f,null,{fallback:y(()=>[(b(),C(S(s.tag),q(I(s.$attrs)),{default:y(()=>[w(s.$slots,"default")]),_:3},16))]),default:y(()=>[W(u,F({ref:"el",tag:s.tag,options:s.options,"watch-options":s.watchOptions},s.$attrs,L(s.handlers)),{default:y(()=>[w(s.$slots,"default")]),_:3},16,["tag","options","watch-options"])]),_:3})}const re=Y(ae,[["render",te]]);export{re as default};
